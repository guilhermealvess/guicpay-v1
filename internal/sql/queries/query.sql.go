// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: query.sql

package queries

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getTransactionByWalletID = `-- name: GetTransactionByWalletID :many
select id, reference_id, wallet_id, type, entries_type, currency, amount, timestamp, snapshot from transactions where wallet_id = $1 and snapshot is null
`

func (q *Queries) GetTransactionByWalletID(ctx context.Context, walletID uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionByWalletID, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceID,
			&i.WalletID,
			&i.Type,
			&i.EntriesType,
			&i.Currency,
			&i.Amount,
			&i.Timestamp,
			&i.Snapshot,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletByID = `-- name: GetWalletByID :many
select 
    w.id as wallet_id,
    w.wallet_type,
    w.customer_name,
    w.document_number,
    w.email,
    w.encoded_password,
    w.phone_number,
    w.created_at,
    w.updated_at,
    t.id as transaction_id,
    t.reference_id,
    t.type as transaction_type,
    t.entries_type,
    t.currency,
    t.amount,
    t.timestamp
from wallets w
inner join transactions t
on w.id = t.wallet_id and t.snapshot is null
where w.id = $1
`

type GetWalletByIDRow struct {
	WalletID        uuid.UUID
	WalletType      WalletType
	CustomerName    string
	DocumentNumber  string
	Email           string
	EncodedPassword string
	PhoneNumber     string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	TransactionID   uuid.UUID
	ReferenceID     uuid.UUID
	TransactionType TransactionType
	EntriesType     TransactionEntryType
	Currency        string
	Amount          int32
	Timestamp       time.Time
}

func (q *Queries) GetWalletByID(ctx context.Context, id uuid.UUID) ([]GetWalletByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getWalletByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWalletByIDRow
	for rows.Next() {
		var i GetWalletByIDRow
		if err := rows.Scan(
			&i.WalletID,
			&i.WalletType,
			&i.CustomerName,
			&i.DocumentNumber,
			&i.Email,
			&i.EncodedPassword,
			&i.PhoneNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TransactionID,
			&i.ReferenceID,
			&i.TransactionType,
			&i.EntriesType,
			&i.Currency,
			&i.Amount,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveTransaction = `-- name: SaveTransaction :exec
insert into transactions(id,reference_id,wallet_id,"type",entries_type,currency,amount,"timestamp") values($1, $2, $3, $4, $5, $6, $7, $8)
`

type SaveTransactionParams struct {
	ID          uuid.UUID
	ReferenceID uuid.UUID
	WalletID    uuid.UUID
	Type        TransactionType
	EntriesType TransactionEntryType
	Currency    string
	Amount      int32
	Timestamp   time.Time
}

func (q *Queries) SaveTransaction(ctx context.Context, arg SaveTransactionParams) error {
	_, err := q.db.ExecContext(ctx, saveTransaction,
		arg.ID,
		arg.ReferenceID,
		arg.WalletID,
		arg.Type,
		arg.EntriesType,
		arg.Currency,
		arg.Amount,
		arg.Timestamp,
	)
	return err
}

const saveWallet = `-- name: SaveWallet :exec
insert into wallets (id,wallet_type,customer_name,document_number,email,encoded_password,phone_number,created_at,updated_at) values($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type SaveWalletParams struct {
	ID              uuid.UUID
	WalletType      WalletType
	CustomerName    string
	DocumentNumber  string
	Email           string
	EncodedPassword string
	PhoneNumber     string
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) SaveWallet(ctx context.Context, arg SaveWalletParams) error {
	_, err := q.db.ExecContext(ctx, saveWallet,
		arg.ID,
		arg.WalletType,
		arg.CustomerName,
		arg.DocumentNumber,
		arg.Email,
		arg.EncodedPassword,
		arg.PhoneNumber,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
