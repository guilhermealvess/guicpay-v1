// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const getTransactionByWalletID = `-- name: GetTransactionByWalletID :many
select id, reference_id, wallet_id, type, entries_type, currency, amount, timestamp, snapshot from transactions where wallet_id = $1 and snapshot is null
`

func (q *Queries) GetTransactionByWalletID(ctx context.Context, walletID uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionByWalletID, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceID,
			&i.WalletID,
			&i.Type,
			&i.EntriesType,
			&i.Currency,
			&i.Amount,
			&i.Timestamp,
			&i.Snapshot,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletByID = `-- name: GetWalletByID :many
select 
    w.id as wallet_id,
    w.wallet_type,
    w.customer_name,
    w.document_number,
    w.email,
    w.encoded_password,
    w.phone_number,
    w.created_at,
    w.updated_at,
    t.id as transaction_id,
    t.reference_id,
    t.type as transaction_type,
    t.entries_type,
    t.currency,
    t.amount,
    t.timestamp
from wallets w
left join transactions t
on w.id = t.wallet_id and t.snapshot is null
where w.id = $1
`

type GetWalletByIDRow struct {
	WalletID        uuid.UUID                `db:"wallet_id" json:"wallet_id"`
	WalletType      WalletType               `db:"wallet_type" json:"wallet_type"`
	CustomerName    string                   `db:"customer_name" json:"customer_name"`
	DocumentNumber  string                   `db:"document_number" json:"document_number"`
	Email           string                   `db:"email" json:"email"`
	EncodedPassword string                   `db:"encoded_password" json:"encoded_password"`
	PhoneNumber     string                   `db:"phone_number" json:"phone_number"`
	CreatedAt       time.Time                `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time                `db:"updated_at" json:"updated_at"`
	TransactionID   uuid.NullUUID            `db:"transaction_id" json:"transaction_id"`
	ReferenceID     uuid.NullUUID            `db:"reference_id" json:"reference_id"`
	TransactionType NullTransactionType      `db:"transaction_type" json:"transaction_type"`
	EntriesType     NullTransactionEntryType `db:"entries_type" json:"entries_type"`
	Currency        sql.NullString           `db:"currency" json:"currency"`
	Amount          sql.NullInt32            `db:"amount" json:"amount"`
	Timestamp       sql.NullTime             `db:"timestamp" json:"timestamp"`
}

func (q *Queries) GetWalletByID(ctx context.Context, id uuid.UUID) ([]GetWalletByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getWalletByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWalletByIDRow
	for rows.Next() {
		var i GetWalletByIDRow
		if err := rows.Scan(
			&i.WalletID,
			&i.WalletType,
			&i.CustomerName,
			&i.DocumentNumber,
			&i.Email,
			&i.EncodedPassword,
			&i.PhoneNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TransactionID,
			&i.ReferenceID,
			&i.TransactionType,
			&i.EntriesType,
			&i.Currency,
			&i.Amount,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveTransaction = `-- name: SaveTransaction :exec
insert into transactions(id,reference_id,wallet_id,"type",entries_type,currency,amount,"timestamp") values($1, $2, $3, $4, $5, $6, $7, $8)
`

type SaveTransactionParams struct {
	ID          uuid.UUID            `db:"id" json:"id"`
	ReferenceID uuid.UUID            `db:"reference_id" json:"reference_id"`
	WalletID    uuid.UUID            `db:"wallet_id" json:"wallet_id"`
	Type        TransactionType      `db:"type" json:"type"`
	EntriesType TransactionEntryType `db:"entries_type" json:"entries_type"`
	Currency    string               `db:"currency" json:"currency"`
	Amount      int32                `db:"amount" json:"amount"`
	Timestamp   time.Time            `db:"timestamp" json:"timestamp"`
}

func (q *Queries) SaveTransaction(ctx context.Context, arg SaveTransactionParams) error {
	_, err := q.db.ExecContext(ctx, saveTransaction,
		arg.ID,
		arg.ReferenceID,
		arg.WalletID,
		arg.Type,
		arg.EntriesType,
		arg.Currency,
		arg.Amount,
		arg.Timestamp,
	)
	return err
}

const saveWallet = `-- name: SaveWallet :exec
insert into wallets (id,wallet_type,customer_name,document_number,email,encoded_password,phone_number,created_at,updated_at) values($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type SaveWalletParams struct {
	ID              uuid.UUID  `db:"id" json:"id"`
	WalletType      WalletType `db:"wallet_type" json:"wallet_type"`
	CustomerName    string     `db:"customer_name" json:"customer_name"`
	DocumentNumber  string     `db:"document_number" json:"document_number"`
	Email           string     `db:"email" json:"email"`
	EncodedPassword string     `db:"encoded_password" json:"encoded_password"`
	PhoneNumber     string     `db:"phone_number" json:"phone_number"`
	CreatedAt       time.Time  `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time  `db:"updated_at" json:"updated_at"`
}

func (q *Queries) SaveWallet(ctx context.Context, arg SaveWalletParams) error {
	_, err := q.db.ExecContext(ctx, saveWallet,
		arg.ID,
		arg.WalletType,
		arg.CustomerName,
		arg.DocumentNumber,
		arg.Email,
		arg.EncodedPassword,
		arg.PhoneNumber,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
